{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/work/Temple4/Temple4/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\ndeclare global {\n  // allow global `var` declarations\n  // eslint-disable-next-line no-var\n  var prisma: PrismaClient | undefined;\n}\n\nexport const prisma =\n  globalThis.prisma ||\n  new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,WAAW,MAAM,IACjB,IAAI,6IAAY;AAElB,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/work/Temple4/Temple4/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions, SessionStrategy } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { prisma } from '@/lib/db';\nimport bcrypt from 'bcryptjs';\n\nexport const authOptions: AuthOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: {  label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: { email: credentials.email.toLowerCase() },\n          include: {\n            profile: true,\n          },\n        });\n\n        if (user && user.password && await bcrypt.compare(credentials.password, user.password)) {\n          // Return user object with required fields for NextAuth\n          return {\n            id: user.id,\n            email: user.email,\n            name: user.profile?.displayName || user.email,\n            isSuperAdmin: user.isSuperAdmin,\n          };\n        } else {\n          return null;\n        }\n      }\n    })\n  ],\n  session: {\n    strategy: 'jwt' as SessionStrategy,\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.email = user.email;\n        token.name = user.name;\n        token.isSuperAdmin = (user as any).isSuperAdmin;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        (session.user as any).id = token.id;\n        session.user.email = token.email as string;\n        session.user.name = token.name as string;\n        (session.user as any).isSuperAdmin = token.isSuperAdmin;\n      }\n      return session;\n    }\n  },\n  pages: {\n    signIn: '/auth/login', // This will be the login page\n  },\n};\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEO,MAAM,cAA2B;IACtC,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,UAAU;oBAAG,OAAO;oBAAY,MAAM;gBAAW;YACnD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,YAAY,QAAQ,EAAE;oBAChD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,qHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE,OAAO,YAAY,KAAK,CAAC,WAAW;oBAAG;oBAChD,SAAS;wBACP,SAAS;oBACX;gBACF;gBAEA,IAAI,QAAQ,KAAK,QAAQ,IAAI,MAAM,8IAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ,GAAG;oBACtF,uDAAuD;oBACvD,OAAO;wBACL,IAAI,KAAK,EAAE;wBACX,OAAO,KAAK,KAAK;wBACjB,MAAM,KAAK,OAAO,EAAE,eAAe,KAAK,KAAK;wBAC7C,cAAc,KAAK,YAAY;oBACjC;gBACF,OAAO;oBACL,OAAO;gBACT;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,KAAK,GAAG,KAAK,KAAK;gBACxB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,YAAY,GAAG,AAAC,KAAa,YAAY;YACjD;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBACf,QAAQ,IAAI,CAAS,EAAE,GAAG,MAAM,EAAE;gBACnC,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;gBAChC,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC7B,QAAQ,IAAI,CAAS,YAAY,GAAG,MAAM,YAAY;YACzD;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;AACF;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/work/Temple4/Temple4/lib/permissions.ts"],"sourcesContent":["import { TenantRole, User, Tenant, ChatMessage, Conversation, UserTenantMembership } from '@prisma/client';\nimport { prisma } from './db';\n\n// Define RolePermissions based on your application's logic, as it's not in Prisma schema\nexport interface RolePermissions {\n  canCreatePosts: boolean;\n  canCreateEvents: boolean;\n  canCreateSermons: boolean;\n  canCreatePodcasts: boolean;\n  canCreateBooks: boolean;\n  canCreateGroupChats: boolean;\n  canInviteMembers: boolean;\n  canApproveMembership: boolean;\n  canBanMembers: boolean;\n  canModeratePosts: boolean;\n  canModerateChats: boolean;\n  canPostInAnnouncementChannels?: boolean;\n  canManagePrayerWall: boolean;\n  canUploadResources: boolean;\n  canManageResources: boolean;\n  canManageContactSubmissions: boolean;\n}\n\n// This can be a simple enum if you don't need the string values\nexport enum TenantRoleType {\n    MEMBER = 'MEMBER',\n    STAFF = 'STAFF',\n    MODERATOR = 'MODERATOR',\n}\n\nasync function getMembershipForUserInTenant(userId: string, tenantId: string): Promise<(UserTenantMembership & { roles: { role: TenantRole }[] }) | null> {\n    return prisma.userTenantMembership.findUnique({\n        where: {\n            userId_tenantId: {\n                userId,\n                tenantId,\n            },\n        },\n        include: {\n            roles: {\n                select: {\n                    role: true\n                }\n            },\n        }\n    });\n}\n\n\n\n/**\n * Maps a specific TenantRole to a more general TenantRoleType for permission lookups.\n */\nfunction getRoleType(role: TenantRole): TenantRoleType | 'ADMIN' {\n    switch (role) {\n        case TenantRole.ADMIN:\n            return 'ADMIN';\n        case TenantRole.STAFF:\n        case TenantRole.CLERGY:\n            return TenantRoleType.STAFF;\n        case TenantRole.MODERATOR:\n            return TenantRoleType.MODERATOR;\n        case TenantRole.MEMBER:\n            return TenantRoleType.MEMBER;\n        default:\n            return TenantRoleType.MEMBER;\n    }\n}\n\n\n/**\n * Checks if a user has a specific permission within a tenant.\n * This is the centralized source of truth for all permission checks.\n *\n * @param user The user to check.\n * @param tenant The tenant context for the permission.\n * @param permission The permission to check for (e.g., 'canCreatePosts').\n * @returns {boolean} True if the user has the permission, false otherwise.\n */\nexport async function can(user: User, tenant: Tenant, permission: keyof RolePermissions): Promise<boolean> {\n  // Super Admins can do anything.\n  if (user.isSuperAdmin) {\n    return true;\n  }\n\n  // Find the user's membership for this specific tenant.\n  const membership = await getMembershipForUserInTenant(user.id, tenant.id);\n\n  // If the user is not a member or not approved, they have no permissions.\n  if (!membership || membership.status !== 'APPROVED') {\n    return false;\n  }\n  \n  // Check if any of the user's roles grant the required permission.\n  for (const roleInfo of membership.roles) {\n    const roleType = getRoleType(roleInfo.role);\n    const permissions = tenant.permissions as any;\n\n    // If permissions is null or undefined, no permissions are granted\n    if (!permissions) {\n      continue;\n    }\n\n    if (roleType === 'ADMIN') {\n        // Admins have all permissions defined under the ADMIN key.\n        if (permissions.ADMIN && permissions.ADMIN[permission]) {\n            return true;\n        }\n    } else {\n        // For other roles, check against their TenantRoleType.\n        const rolePerms = permissions[roleType];\n        if (rolePerms && rolePerms[permission]) {\n            return true; // Permission granted by at least one role.\n        }\n    }\n  }\n\n  return false; // No role granted the permission.\n}\n\n/**\n * Checks if a user has a specific role within a tenant.\n *\n * @param user The user to check.\n * @param tenantId The ID of the tenant context for the role.\n * @param role The role to check for.\n * @returns {boolean} True if the user has the role, false otherwise.\n */\nexport async function hasRole(userId: string, tenantId: string, requiredRoles: TenantRole[]): Promise<boolean> {\n  const membership = await getMembershipForUserInTenant(userId, tenantId);\n\n  if (!membership || membership.status !== 'APPROVED') {\n    return false;\n  }\n\n  return membership.roles.some(roleInfo => requiredRoles.includes(roleInfo.role));\n}\n\n/**\n * Checks if a user can view a certain type of content (e.g., posts, events).\n * It checks tenant settings for public visibility and feature enablement.\n *\n * @param userId The ID of the user attempting to view. Can be null for anonymous users.\n * @param tenantId The ID of the tenant where the content resides.\n * @param contentType The key for the content type in tenant settings (e.g., 'posts', 'calendar').\n * @returns {Promise<boolean>} True if the user can view the content.\n */\nexport async function canUserViewContent(userId: string | null, tenantId: string, contentType: 'posts' | 'calendar' | 'sermons' | 'podcasts' | 'books' | 'prayerWall'): Promise<boolean> {\n    try {\n        const tenant = await prisma.tenant.findUnique({\n            where: { id: tenantId },\n            include: { settings: true }\n        });\n\n        if (!tenant || !tenant.settings) {\n            return false;\n        }\n\n        const settings = tenant.settings as any;\n\n        // Check if the entire feature is disabled\n        const featureFlag = `enable${contentType.charAt(0).toUpperCase() + contentType.slice(1)}`;\n        if (!settings[featureFlag]) {\n            return false;\n        }\n\n        const membership = userId ? await getMembershipForUserInTenant(userId, tenantId) : null;\n\n        // If user is not a member, check public visibility settings\n        if (!membership || membership.status !== 'APPROVED') {\n            // Check if visitorVisibility exists and has the content type property\n            if (!settings.visitorVisibility || typeof settings.visitorVisibility !== 'object') {\n                return false;\n            }\n            const result = settings.visitorVisibility[contentType] === true;\n            return result;\n        }\n\n        // If they are an approved member, they can view it as long as the feature is enabled.\n        return true;\n    } catch (error) {\n        console.error('[canUserViewContent] Error:', error);\n        throw error;\n    }\n}\n\n/**\n * Checks if a user has permission to create a post in a tenant.\n *\n * @param userId The ID of the user.\n * @param tenantId The ID of the tenant.\n * @param isAnnouncement Whether the post is an announcement.\n * @returns {Promise<boolean>} True if the user can create the post.\n */\nexport async function canUserPost(userId: string, tenantId: string, isAnnouncement: boolean): Promise<boolean> {\n    const user = await prisma.user.findUnique({ where: { id: userId } });\n    const tenant = await prisma.tenant.findUnique({ where: { id: tenantId } });\n\n    if (!user || !tenant) return false;\n\n    if (isAnnouncement) {\n        return can(user, tenant, 'canPostInAnnouncementChannels');\n    }\n    return can(user, tenant, 'canCreatePosts');\n}\n\n\n/**\n * Checks if a user can delete a specific message.\n */\nexport async function canDeleteMessage(\n  user: User,\n  message: ChatMessage,\n  conversation: Conversation,\n  tenant: Tenant\n): Promise<boolean> {\n  if (user.isSuperAdmin) {\n    return true;\n  }\n  // User can delete their own message\n  if (message.userId === user.id) {\n    return true;\n  }\n  // Check for moderation permissions\n  if (!conversation.isDirectMessage) { // isGroupChat\n    if (await can(user, tenant, 'canModerateChats')) {\n      return true;\n    }\n  }\n  return false;\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/work/Temple4/Temple4/app/api/tenants/%5BtenantId%5D/admin/branding/route.ts"],"sourcesContent":["import { getServerSession } from 'next-auth/next';\nimport { authOptions } from '@/app/api/auth/[...nextauth]/route';\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/db';\nimport { hasRole } from '@/lib/permissions';\nimport { z } from 'zod';\nimport { TenantRole } from '@prisma/client';\n\n// 17.3 Get Tenant Branding\nexport async function GET(\n  request: Request,\n  { params }: { params: { tenantId: string } }\n) {\n    const session = await getServerSession(authOptions);\n    const user = session?.user as any;\n\n    if (!user) {\n        return NextResponse.json({ message: 'Not authenticated' }, { status: 401 });\n    }\n\n    try {\n        const isAdmin = await hasRole(user.id, params.tenantId, [TenantRole.ADMIN]);\n        if (!isAdmin) {\n            return NextResponse.json({ message: 'You do not have permission to view tenant branding.' }, { status: 403 });\n        }\n\n        const branding = await prisma.tenantBranding.findUnique({\n            where: { tenantId: params.tenantId },\n        });\n\n        return NextResponse.json(branding);\n    } catch (error) {\n        console.error(`Failed to fetch tenant branding for tenant ${params.tenantId}:`, error);\n        return NextResponse.json({ message: 'Failed to fetch tenant branding' }, { status: 500 });\n    }\n}\n\nconst brandingSchema = z.object({\n    logoUrl: z.string().url().optional(),\n    bannerImageUrl: z.string().url().optional(),\n    primaryColor: z.string().optional(),\n    accentColor: z.string().optional(),\n    customLinks: z.array(z.object({ label: z.string(), url: z.string().url() })).optional(),\n});\n\n// 17.4 Update Tenant Branding\nexport async function PUT(\n  request: Request,\n  { params }: { params: { tenantId: string } }\n) {\n    const session = await getServerSession(authOptions);\n    const user = session?.user as any;\n\n    if (!user) {\n        return NextResponse.json({ message: 'Not authenticated' }, { status: 401 });\n    }\n\n    const result = brandingSchema.safeParse(await request.json());\n    if (!result.success) {\n        return NextResponse.json({ errors: result.error.flatten().fieldErrors }, { status: 400 });\n    }\n\n    try {\n        const isAdmin = await hasRole(user.id, params.tenantId, [TenantRole.ADMIN]);\n        if (!isAdmin) {\n            return NextResponse.json({ message: 'You do not have permission to update tenant branding.' }, { status: 403 });\n        }\n\n        const updatedBranding = await prisma.tenantBranding.update({\n            where: { tenantId: params.tenantId },\n            data: result.data,\n        });\n\n        return NextResponse.json(updatedBranding);\n    } catch (error) {\n        console.error(`Failed to update tenant branding for tenant ${params.tenantId}:`, error);\n        return NextResponse.json({ message: 'Failed to update tenant branding' }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAGO,eAAe,IACpB,OAAgB,EAChB,EAAE,MAAM,EAAoC;IAE1C,MAAM,UAAU,MAAM,IAAA,mKAAgB,EAAC,kKAAW;IAClD,MAAM,OAAO,SAAS;IAEtB,IAAI,CAAC,MAAM;QACP,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAoB,GAAG;YAAE,QAAQ;QAAI;IAC7E;IAEA,IAAI;QACA,MAAM,UAAU,MAAM,IAAA,+HAAO,EAAC,KAAK,EAAE,EAAE,OAAO,QAAQ,EAAE;YAAC,2IAAU,CAAC,KAAK;SAAC;QAC1E,IAAI,CAAC,SAAS;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAsD,GAAG;gBAAE,QAAQ;YAAI;QAC/G;QAEA,MAAM,WAAW,MAAM,qHAAM,CAAC,cAAc,CAAC,UAAU,CAAC;YACpD,OAAO;gBAAE,UAAU,OAAO,QAAQ;YAAC;QACvC;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,2CAA2C,EAAE,OAAO,QAAQ,CAAC,CAAC,CAAC,EAAE;QAChF,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAkC,GAAG;YAAE,QAAQ;QAAI;IAC3F;AACJ;AAEA,MAAM,iBAAiB,oLAAC,CAAC,MAAM,CAAC;IAC5B,SAAS,oLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ;IAClC,gBAAgB,oLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ;IACzC,cAAc,oLAAC,CAAC,MAAM,GAAG,QAAQ;IACjC,aAAa,oLAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,aAAa,oLAAC,CAAC,KAAK,CAAC,oLAAC,CAAC,MAAM,CAAC;QAAE,OAAO,oLAAC,CAAC,MAAM;QAAI,KAAK,oLAAC,CAAC,MAAM,GAAG,GAAG;IAAG,IAAI,QAAQ;AACzF;AAGO,eAAe,IACpB,OAAgB,EAChB,EAAE,MAAM,EAAoC;IAE1C,MAAM,UAAU,MAAM,IAAA,mKAAgB,EAAC,kKAAW;IAClD,MAAM,OAAO,SAAS;IAEtB,IAAI,CAAC,MAAM;QACP,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAoB,GAAG;YAAE,QAAQ;QAAI;IAC7E;IAEA,MAAM,SAAS,eAAe,SAAS,CAAC,MAAM,QAAQ,IAAI;IAC1D,IAAI,CAAC,OAAO,OAAO,EAAE;QACjB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,QAAQ,OAAO,KAAK,CAAC,OAAO,GAAG,WAAW;QAAC,GAAG;YAAE,QAAQ;QAAI;IAC3F;IAEA,IAAI;QACA,MAAM,UAAU,MAAM,IAAA,+HAAO,EAAC,KAAK,EAAE,EAAE,OAAO,QAAQ,EAAE;YAAC,2IAAU,CAAC,KAAK;SAAC;QAC1E,IAAI,CAAC,SAAS;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAwD,GAAG;gBAAE,QAAQ;YAAI;QACjH;QAEA,MAAM,kBAAkB,MAAM,qHAAM,CAAC,cAAc,CAAC,MAAM,CAAC;YACvD,OAAO;gBAAE,UAAU,OAAO,QAAQ;YAAC;YACnC,MAAM,OAAO,IAAI;QACrB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,4CAA4C,EAAE,OAAO,QAAQ,CAAC,CAAC,CAAC,EAAE;QACjF,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAmC,GAAG;YAAE,QAAQ;QAAI;IAC5F;AACJ"}}]
}