{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\ndeclare global {\r\n  // allow global `var` declarations\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  globalThis.prisma ||\r\n  new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,WAAW,MAAM,IACjB,IAAI,6IAAY;AAElB,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions, SessionStrategy } from 'next-auth';\r\nimport CredentialsProvider from 'next-auth/providers/credentials';\r\nimport { prisma } from '@/lib/db';\r\nimport bcrypt from 'bcryptjs';\r\n\r\nexport const authOptions: AuthOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: 'Credentials',\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"text\" },\r\n        password: {  label: \"Password\", type: \"password\" }\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials.password) {\r\n          return null;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { email: credentials.email.toLowerCase() },\r\n          include: {\r\n            profile: true,\r\n          },\r\n        });\r\n\r\n        if (user && user.password && await bcrypt.compare(credentials.password, user.password)) {\r\n          // Return user object with required fields for NextAuth\r\n          return {\r\n            id: user.id,\r\n            email: user.email,\r\n            name: user.profile?.displayName || user.email,\r\n            isSuperAdmin: user.isSuperAdmin,\r\n          };\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n    })\r\n  ],\r\n  session: {\r\n    strategy: 'jwt' as SessionStrategy,\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.id = user.id;\r\n        token.email = user.email;\r\n        token.name = user.name;\r\n        token.isSuperAdmin = (user as any).isSuperAdmin;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }) {\r\n      if (session.user) {\r\n        (session.user as any).id = token.id;\r\n        session.user.email = token.email as string;\r\n        session.user.name = token.name as string;\r\n        (session.user as any).isSuperAdmin = token.isSuperAdmin;\r\n      }\r\n      return session;\r\n    }\r\n  },\r\n  pages: {\r\n    signIn: '/auth/login', // This will be the login page\r\n  },\r\n};\r\n\r\nconst handler = NextAuth(authOptions);\r\n\r\nexport { handler as GET, handler as POST };\r\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEO,MAAM,cAA2B;IACtC,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,UAAU;oBAAG,OAAO;oBAAY,MAAM;gBAAW;YACnD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,YAAY,QAAQ,EAAE;oBAChD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,qHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE,OAAO,YAAY,KAAK,CAAC,WAAW;oBAAG;oBAChD,SAAS;wBACP,SAAS;oBACX;gBACF;gBAEA,IAAI,QAAQ,KAAK,QAAQ,IAAI,MAAM,8IAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ,GAAG;oBACtF,uDAAuD;oBACvD,OAAO;wBACL,IAAI,KAAK,EAAE;wBACX,OAAO,KAAK,KAAK;wBACjB,MAAM,KAAK,OAAO,EAAE,eAAe,KAAK,KAAK;wBAC7C,cAAc,KAAK,YAAY;oBACjC;gBACF,OAAO;oBACL,OAAO;gBACT;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,KAAK,GAAG,KAAK,KAAK;gBACxB,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,YAAY,GAAG,AAAC,KAAa,YAAY;YACjD;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBACf,QAAQ,IAAI,CAAS,EAAE,GAAG,MAAM,EAAE;gBACnC,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;gBAChC,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC7B,QAAQ,IAAI,CAAS,YAAY,GAAG,MAAM,YAAY;YACzD;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;AACF;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/lib/permissions.ts"],"sourcesContent":["import { TenantRole, User, Tenant, ChatMessage, Conversation, UserTenantMembership } from '@prisma/client';\r\nimport { prisma } from './db';\r\n\r\n// Define RolePermissions based on your application's logic, as it's not in Prisma schema\r\nexport interface RolePermissions {\r\n  canCreatePosts: boolean;\r\n  canCreateEvents: boolean;\r\n  canCreateSermons: boolean;\r\n  canCreatePodcasts: boolean;\r\n  canCreateBooks: boolean;\r\n  canCreateGroupChats: boolean;\r\n  canInviteMembers: boolean;\r\n  canApproveMembership: boolean;\r\n  canBanMembers: boolean;\r\n  canModeratePosts: boolean;\r\n  canModerateChats: boolean;\r\n  canPostInAnnouncementChannels?: boolean;\r\n  canManagePrayerWall: boolean;\r\n  canUploadResources: boolean;\r\n  canManageResources: boolean;\r\n  canManageContactSubmissions: boolean;\r\n}\r\n\r\n// This can be a simple enum if you don't need the string values\r\nexport enum TenantRoleType {\r\n    MEMBER = 'MEMBER',\r\n    STAFF = 'STAFF',\r\n    MODERATOR = 'MODERATOR',\r\n}\r\n\r\nasync function getMembershipForUserInTenant(userId: string, tenantId: string): Promise<(UserTenantMembership & { roles: { role: TenantRole }[] }) | null> {\r\n    return prisma.userTenantMembership.findUnique({\r\n        where: {\r\n            userId_tenantId: {\r\n                userId,\r\n                tenantId,\r\n            },\r\n        },\r\n        include: {\r\n            roles: {\r\n                select: {\r\n                    role: true\r\n                }\r\n            },\r\n        }\r\n    });\r\n}\r\n\r\n\r\n\r\n/**\r\n * Maps a specific TenantRole to a more general TenantRoleType for permission lookups.\r\n */\r\nfunction getRoleType(role: TenantRole): TenantRoleType | 'ADMIN' {\r\n    switch (role) {\r\n        case TenantRole.ADMIN:\r\n            return 'ADMIN';\r\n        case TenantRole.STAFF:\r\n        case TenantRole.CLERGY:\r\n            return TenantRoleType.STAFF;\r\n        case TenantRole.MODERATOR:\r\n            return TenantRoleType.MODERATOR;\r\n        case TenantRole.MEMBER:\r\n            return TenantRoleType.MEMBER;\r\n        default:\r\n            return TenantRoleType.MEMBER;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Checks if a user has a specific permission within a tenant.\r\n * This is the centralized source of truth for all permission checks.\r\n *\r\n * @param user The user to check.\r\n * @param tenant The tenant context for the permission.\r\n * @param permission The permission to check for (e.g., 'canCreatePosts').\r\n * @returns {boolean} True if the user has the permission, false otherwise.\r\n */\r\nexport async function can(user: User, tenant: Tenant, permission: keyof RolePermissions): Promise<boolean> {\r\n  // Super Admins can do anything.\r\n  if (user.isSuperAdmin) {\r\n    return true;\r\n  }\r\n\r\n  // Find the user's membership for this specific tenant.\r\n  const membership = await getMembershipForUserInTenant(user.id, tenant.id);\r\n\r\n  // If the user is not a member or not approved, they have no permissions.\r\n  if (!membership || membership.status !== 'APPROVED') {\r\n    return false;\r\n  }\r\n  \r\n  // Check if any of the user's roles grant the required permission.\r\n  for (const roleInfo of membership.roles) {\r\n    const roleType = getRoleType(roleInfo.role);\r\n    const permissions = tenant.permissions as any;\r\n\r\n    // If permissions is null or undefined, no permissions are granted\r\n    if (!permissions) {\r\n      continue;\r\n    }\r\n\r\n    if (roleType === 'ADMIN') {\r\n        // Admins have all permissions defined under the ADMIN key.\r\n        if (permissions.ADMIN && permissions.ADMIN[permission]) {\r\n            return true;\r\n        }\r\n    } else {\r\n        // For other roles, check against their TenantRoleType.\r\n        const rolePerms = permissions[roleType];\r\n        if (rolePerms && rolePerms[permission]) {\r\n            return true; // Permission granted by at least one role.\r\n        }\r\n    }\r\n  }\r\n\r\n  return false; // No role granted the permission.\r\n}\r\n\r\n/**\r\n * Checks if a user has a specific role within a tenant.\r\n *\r\n * @param user The user to check.\r\n * @param tenantId The ID of the tenant context for the role.\r\n * @param role The role to check for.\r\n * @returns {boolean} True if the user has the role, false otherwise.\r\n */\r\nexport async function hasRole(userId: string, tenantId: string, requiredRoles: TenantRole[]): Promise<boolean> {\r\n  const membership = await getMembershipForUserInTenant(userId, tenantId);\r\n\r\n  if (!membership || membership.status !== 'APPROVED') {\r\n    return false;\r\n  }\r\n\r\n  return membership.roles.some(roleInfo => requiredRoles.includes(roleInfo.role));\r\n}\r\n\r\n/**\r\n * Checks if a user can view a certain type of content (e.g., posts, events).\r\n * It checks tenant settings for public visibility and feature enablement.\r\n *\r\n * @param userId The ID of the user attempting to view. Can be null for anonymous users.\r\n * @param tenantId The ID of the tenant where the content resides.\r\n * @param contentType The key for the content type in tenant settings (e.g., 'posts', 'calendar').\r\n * @returns {Promise<boolean>} True if the user can view the content.\r\n */\r\nexport async function canUserViewContent(userId: string | null, tenantId: string, contentType: 'posts' | 'calendar' | 'sermons' | 'podcasts' | 'books' | 'prayerWall'): Promise<boolean> {\r\n    try {\r\n        const tenant = await prisma.tenant.findUnique({\r\n            where: { id: tenantId },\r\n            include: { settings: true }\r\n        });\r\n\r\n        if (!tenant || !tenant.settings) {\r\n            return false;\r\n        }\r\n\r\n        const settings = tenant.settings as any;\r\n\r\n        // Check if the entire feature is disabled\r\n        const featureFlag = `enable${contentType.charAt(0).toUpperCase() + contentType.slice(1)}`;\r\n        if (!settings[featureFlag]) {\r\n            return false;\r\n        }\r\n\r\n        const membership = userId ? await getMembershipForUserInTenant(userId, tenantId) : null;\r\n\r\n        // If user is not a member, check public visibility settings\r\n        if (!membership || membership.status !== 'APPROVED') {\r\n            // Check if visitorVisibility exists and has the content type property\r\n            if (!settings.visitorVisibility || typeof settings.visitorVisibility !== 'object') {\r\n                return false;\r\n            }\r\n            const result = settings.visitorVisibility[contentType] === true;\r\n            return result;\r\n        }\r\n\r\n        // If they are an approved member, they can view it as long as the feature is enabled.\r\n        return true;\r\n    } catch (error) {\r\n        console.error('[canUserViewContent] Error:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if a user has permission to create a post in a tenant.\r\n *\r\n * @param userId The ID of the user.\r\n * @param tenantId The ID of the tenant.\r\n * @param isAnnouncement Whether the post is an announcement.\r\n * @returns {Promise<boolean>} True if the user can create the post.\r\n */\r\nexport async function canUserPost(userId: string, tenantId: string, isAnnouncement: boolean): Promise<boolean> {\r\n    const user = await prisma.user.findUnique({ where: { id: userId } });\r\n    const tenant = await prisma.tenant.findUnique({ where: { id: tenantId } });\r\n\r\n    if (!user || !tenant) return false;\r\n\r\n    if (isAnnouncement) {\r\n        return can(user, tenant, 'canPostInAnnouncementChannels');\r\n    }\r\n    return can(user, tenant, 'canCreatePosts');\r\n}\r\n\r\n\r\n/**\r\n * Checks if a user can delete a specific message.\r\n */\r\nexport async function canDeleteMessage(\r\n  user: User,\r\n  message: ChatMessage,\r\n  conversation: Conversation,\r\n  tenant: Tenant\r\n): Promise<boolean> {\r\n  if (user.isSuperAdmin) {\r\n    return true;\r\n  }\r\n  // User can delete their own message\r\n  if (message.userId === user.id) {\r\n    return true;\r\n  }\r\n  // Check for moderation permissions\r\n  if (!conversation.isDirectMessage) { // isGroupChat\r\n    if (await can(user, tenant, 'canModerateChats')) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/app/api/tenants/%5BtenantId%5D/admin/contact-submissions/route.ts"],"sourcesContent":["import { getServerSession } from 'next-auth/next';\r\nimport { authOptions } from '@/app/api/auth/[...nextauth]/route';\r\nimport { NextResponse } from 'next/server';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { can } from '@/lib/permissions';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// 17.5 Get Contact Submissions\r\nexport async function GET(\r\n  request: Request,\r\n  { params }: { params: { tenantId: string } }\r\n) {\r\n    const session = await getServerSession(authOptions);\r\n    const user = session?.user as any;\r\n\r\n    if (!user) {\r\n        return NextResponse.json({ message: 'Not authenticated' }, { status: 401 });\r\n    }\r\n\r\n    try {\r\n        const tenant = await prisma.tenant.findUnique({ where: { id: params.tenantId } });\r\n        if (!tenant) {\r\n            return NextResponse.json({ message: 'Tenant not found' }, { status: 404 });\r\n        }\r\n\r\n        const canViewSubmissions = await can(user, tenant, 'canManageContactSubmissions');\r\n        if (!canViewSubmissions) {\r\n            return NextResponse.json({ message: 'You do not have permission to view contact submissions.' }, { status: 403 });\r\n        }\r\n\r\n        const submissions = await prisma.contactSubmission.findMany({\r\n            where: { tenantId: params.tenantId },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n\r\n        return NextResponse.json(submissions);\r\n    } catch (error) {\r\n        console.error(`Failed to fetch contact submissions for tenant ${params.tenantId}:`, error);\r\n        return NextResponse.json({ message: 'Failed to fetch contact submissions' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAGxB,eAAe,IACpB,OAAgB,EAChB,EAAE,MAAM,EAAoC;IAE1C,MAAM,UAAU,MAAM,IAAA,mKAAgB,EAAC,kKAAW;IAClD,MAAM,OAAO,SAAS;IAEtB,IAAI,CAAC,MAAM;QACP,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAoB,GAAG;YAAE,QAAQ;QAAI;IAC7E;IAEA,IAAI;QACA,MAAM,SAAS,MAAM,OAAO,MAAM,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI,OAAO,QAAQ;YAAC;QAAE;QAC/E,IAAI,CAAC,QAAQ;YACT,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QAC5E;QAEA,MAAM,qBAAqB,MAAM,IAAA,2HAAG,EAAC,MAAM,QAAQ;QACnD,IAAI,CAAC,oBAAoB;YACrB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA0D,GAAG;gBAAE,QAAQ;YAAI;QACnH;QAEA,MAAM,cAAc,MAAM,OAAO,iBAAiB,CAAC,QAAQ,CAAC;YACxD,OAAO;gBAAE,UAAU,OAAO,QAAQ;YAAC;YACnC,SAAS;gBAAE,WAAW;YAAO;QACjC;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,+CAA+C,EAAE,OAAO,QAAQ,CAAC,CAAC,CAAC,EAAE;QACpF,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAsC,GAAG;YAAE,QAAQ;QAAI;IAC/F;AACJ"}}]
}