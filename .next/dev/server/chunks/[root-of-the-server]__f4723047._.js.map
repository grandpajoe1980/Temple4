{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\ndeclare global {\r\n  // allow global `var` declarations\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  globalThis.prisma ||\r\n  new PrismaClient({\r\n    log: ['query'],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,WAAW,MAAM,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/lib/data.ts"],"sourcesContent":["import { prisma } from './db';\r\nimport { Tenant, User, Post, Event, UserTenantMembership, Notification, AuditLog, Conversation, TenantRole, MembershipStatus, TenantSettings, TenantBranding } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\n\r\ntype TenantWithDetails = Tenant & {\r\n    settings: TenantSettings | null;\r\n    branding: TenantBranding | null;\r\n};\r\n\r\nexport async function getTenantsForUser(userId: string): Promise<Tenant[]> {\r\n  const memberships = await prisma.userTenantMembership.findMany({\r\n    where: {\r\n      userId: userId,\r\n      status: 'APPROVED',\r\n    },\r\n    include: {\r\n      tenant: true,\r\n    },\r\n  });\r\n\r\n  return memberships.map((membership: { tenant: Tenant; }) => membership.tenant);\r\n}\r\n\r\nexport async function getTenantById(tenantId: string) {\r\n  return await prisma.tenant.findUnique({\r\n    where: { id: tenantId },\r\n    include: {\r\n      settings: true,\r\n      branding: true,\r\n    },\r\n  });\r\n}\r\n\r\nexport async function getUserById(userId: string) {\r\n  return await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    include: {\r\n      profile: true,\r\n      privacySettings: true,\r\n      accountSettings: true,\r\n    },\r\n  });\r\n}\r\n\r\nexport async function getTenants(): Promise<Tenant[]> {\r\n    return await prisma.tenant.findMany({\r\n        include: {\r\n            settings: true,\r\n            branding: true,\r\n        }\r\n    });\r\n}\r\n\r\nexport async function getEventsForTenant(tenantId: string): Promise<Event[]> {\r\n  return await prisma.event.findMany({\r\n    where: { tenantId },\r\n    orderBy: { startDateTime: 'asc' },\r\n  });\r\n}\r\n\r\nexport async function getPostsForTenant(tenantId: string): Promise<Post[]> {\r\n  return await prisma.post.findMany({\r\n    where: { tenantId, isPublished: true },\r\n    orderBy: { publishedAt: 'desc' },\r\n    include: {\r\n      author: {\r\n        include: {\r\n          profile: true,\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nexport async function getMembershipForUserInTenant(userId: string, tenantId: string): Promise<UserTenantMembership | null> {\r\n  return await prisma.userTenantMembership.findUnique({\r\n    where: {\r\n      userId_tenantId: {\r\n        userId,\r\n        tenantId,\r\n      }\r\n    },\r\n  });\r\n}\r\n\r\nexport async function getNotificationsForUser(userId: string): Promise<Notification[]> {\r\n    return await prisma.notification.findMany({\r\n        where: { userId },\r\n        orderBy: { createdAt: 'desc' },\r\n    });\r\n}\r\n\r\nexport async function markNotificationAsRead(notificationId: string): Promise<Notification> {\r\n    return await prisma.notification.update({\r\n        where: { id: notificationId },\r\n        data: { isRead: true },\r\n    });\r\n}\r\n\r\nexport async function markAllNotificationsAsRead(userId: string) {\r\n    return await prisma.notification.updateMany({\r\n        where: { userId },\r\n        data: { isRead: true },\r\n    });\r\n}\r\n\r\nexport async function getUserByEmail(email: string) {\r\n    return await prisma.user.findUnique({\r\n        where: { email },\r\n        include: {\r\n            profile: true,\r\n            privacySettings: true,\r\n            accountSettings: true,\r\n        },\r\n    });\r\n}\r\n\r\nexport async function registerUser(displayName: string, email: string, pass: string) {\r\n    const existingUser = await getUserByEmail(email);\r\n    if (existingUser) {\r\n        return { success: false, message: 'User with this email already exists.' };\r\n    }\r\n    const hashedPassword = await bcrypt.hash(pass, 10);\r\n    const user = await prisma.user.create({\r\n        data: {\r\n            email,\r\n            password: hashedPassword,\r\n            profile: {\r\n                create: {\r\n                    displayName,\r\n                },\r\n            },\r\n            accountSettings: { create: {} },\r\n            privacySettings: { create: {} },\r\n        },\r\n        include: {\r\n            profile: true,\r\n            privacySettings: true,\r\n            accountSettings: true,\r\n        }\r\n    });\r\n    return { success: true, user };\r\n}\r\n\r\nexport async function createTenant(tenantDetails: Omit<Tenant, 'id' | 'slug' | 'permissions'>, ownerId: string): Promise<Tenant> {\r\n    const tenant = await prisma.tenant.create({\r\n        data: {\r\n            ...tenantDetails,\r\n            slug: tenantDetails.name.toLowerCase().replace(/ /g, '-'),\r\n            memberships: {\r\n                create: {\r\n                    userId: ownerId,\r\n                    roles: {\r\n                        create: {\r\n                            role: TenantRole.ADMIN,\r\n                        }\r\n                    },\r\n                    status: MembershipStatus.APPROVED,\r\n                }\r\n            },\r\n            settings: { \r\n                create: {\r\n                    isPublic: false,\r\n                    membershipApprovalMode: 'APPROVAL_REQUIRED',\r\n                    enableCalendar: true,\r\n                    enablePosts: true,\r\n                    enableSermons: true,\r\n                    enablePodcasts: true,\r\n                    enableBooks: true,\r\n                    enableDonations: true,\r\n                    enableVolunteering: true,\r\n                    enableSmallGroups: true,\r\n                    enableLiveStream: true,\r\n                    enablePrayerWall: true,\r\n                    enableResourceCenter: true,\r\n                    visitorVisibility: {},\r\n                    donationSettings: {},\r\n                    liveStreamSettings: {},\r\n                } \r\n            },\r\n            branding: { \r\n                create: {\r\n                    logoUrl: '',\r\n                    bannerImageUrl: '',\r\n                    primaryColor: '#000000',\r\n                    accentColor: '#FFFFFF',\r\n                    customLinks: [],\r\n                } \r\n            },\r\n        }\r\n    });\r\n    return tenant;\r\n}\r\n\r\nexport async function updateTenant(tenant: Partial<TenantWithDetails>): Promise<Tenant> {\r\n    const { id, settings, branding, ...data } = tenant;\r\n    \r\n    const updateData: any = { ...data };\r\n\r\n    if (settings) {\r\n        const { id: settingsId, tenantId: settingsTenantId, ...restOfSettings } = settings;\r\n        updateData.settings = {\r\n            update: {\r\n                ...restOfSettings,\r\n                visitorVisibility: restOfSettings.visitorVisibility || undefined,\r\n                donationSettings: restOfSettings.donationSettings || undefined,\r\n                liveStreamSettings: restOfSettings.liveStreamSettings || undefined,\r\n            }\r\n        };\r\n    }\r\n\r\n    if (branding) {\r\n        const { id: brandingId, tenantId: brandingTenantId, ...restOfBranding } = branding;\r\n        updateData.branding = {\r\n            update: {\r\n                ...restOfBranding,\r\n                customLinks: restOfBranding.customLinks || undefined,\r\n            }\r\n        };\r\n    }\r\n\r\n    return await prisma.tenant.update({\r\n        where: { id },\r\n        data: updateData,\r\n    });\r\n}\r\n\r\nexport async function requestToJoinTenant(userId: string, tenantId: string): Promise<UserTenantMembership> {\r\n    const existingMembership = await getMembershipForUserInTenant(userId, tenantId);\r\nif (existingMembership) {\r\n        return existingMembership;\r\n    }\r\n    return await prisma.userTenantMembership.create({\r\n        data: {\r\n            userId,\r\n            tenantId,\r\n            roles: {\r\n                create: {\r\n                    role: TenantRole.MEMBER,\r\n                }\r\n            },\r\n            status: MembershipStatus.PENDING,\r\n        }\r\n    });\r\n}\r\n\r\n// NOTE: These are not secure and are for demonstration only.\r\n// In a real app, you'd use secure tokens and a proper reset flow.\r\nexport async function requestPasswordReset(email: string): Promise<boolean> {\r\n    const user = await getUserByEmail(email);\r\n    if (!user) return false;\r\n    // In a real app, generate a token, save it, and email a link.\r\n    console.log(`Password reset requested for ${email}. In this demo, we'll just allow a direct reset.`);\r\n    return true;\r\n}\r\n\r\nexport async function resetPassword(email: string, newPass: string) {\r\n    const user = await getUserByEmail(email);\r\n    if (!user) return { success: false, message: \"User not found.\" };\r\n    const hashedPassword = await bcrypt.hash(newPass, 10);\r\n    await prisma.user.update({\r\n        where: { email },\r\n        data: { password: hashedPassword },\r\n    });\r\n    return { success: true };\r\n}\r\n\r\nexport async function logAuditEvent(event: Omit<AuditLog, 'id' | 'createdAt'>): Promise<AuditLog> {\r\n    return await prisma.auditLog.create({\r\n        data: {\r\n            ...event,\r\n            metadata: event.metadata || {},\r\n        },\r\n    });\r\n}\r\n\r\nexport async function getOrCreateDirectConversation(userId1: string, userId2: string): Promise<Conversation> {\r\n    const existing = await prisma.conversation.findFirst({\r\n        where: {\r\n            isDirectMessage: true,\r\n            participants: {\r\n                every: {\r\n                    userId: { in: [userId1, userId2] }\r\n                }\r\n            }\r\n        },\r\n        include: { participants: true }\r\n    });\r\n\r\n    if (existing) return existing;\r\n\r\n    return await prisma.conversation.create({\r\n        data: {\r\n            isDirectMessage: true,\r\n            participants: {\r\n                create: [\r\n                    { userId: userId1 },\r\n                    { userId: userId2 },\r\n                ]\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport async function getConversationsForUser(userId: string) {\r\n    return await prisma.conversation.findMany({\r\n        where: {\r\n            participants: {\r\n                some: {\r\n                    userId: userId\r\n                }\r\n            }\r\n        },\r\n        include: {\r\n            participants: {\r\n                include: {\r\n                    user: {\r\n                        include: {\r\n                            profile: true\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            messages: {\r\n                orderBy: {\r\n                    createdAt: 'desc'\r\n                },\r\n                take: 1,\r\n                include: {\r\n                    user: {\r\n                        include: {\r\n                            profile: true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        orderBy: {\r\n            id: 'desc'\r\n        }\r\n    });\r\n}\r\n\r\nexport async function getMessagesForConversation(conversationId: string) {\r\n    return await prisma.chatMessage.findMany({\r\n        where: {\r\n            conversationId: conversationId\r\n        },\r\n        include: {\r\n            user: {\r\n                include: {\r\n                    profile: true\r\n                }\r\n            }\r\n        },\r\n        orderBy: {\r\n            createdAt: 'asc'\r\n        }\r\n    });\r\n}\r\n\r\nexport async function addMessage(conversationId: string, senderId: string, content: string) {\r\n    const message = await prisma.chatMessage.create({\r\n        data: {\r\n            conversationId,\r\n            userId: senderId,\r\n            text: content\r\n        },\r\n        include: {\r\n            user: {\r\n                include: {\r\n                    profile: true\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    return message;\r\n}\r\n\r\nexport async function deleteMessage(messageId: string) {\r\n    return await prisma.chatMessage.delete({\r\n        where: { id: messageId }\r\n    });\r\n}\r\n\r\nexport async function markConversationAsRead(conversationId: string, userId: string) {\r\n    // This would update read receipts via ConversationParticipant's lastReadMessageId\r\n    // For now, just return success\r\n    return { success: true };\r\n}\r\n\r\nexport async function getAllUsers() {\r\n    return await prisma.user.findMany({\r\n        include: {\r\n            profile: true\r\n        }\r\n    });\r\n}\r\n\r\nexport async function getAuditLogs() {\r\n    return await prisma.auditLog.findMany({\r\n        include: {\r\n            actorUser: {\r\n                include: {\r\n                    profile: true\r\n                }\r\n            },\r\n            effectiveUser: {\r\n                include: {\r\n                    profile: true\r\n                }\r\n            }\r\n        },\r\n        orderBy: {\r\n            createdAt: 'desc'\r\n        },\r\n        take: 100\r\n    });\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/josep/VSCODEprojects/Temple/Temple4/app/api/conversations/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getServerSession } from 'next-auth/next';\r\nimport { authOptions } from '../../auth/[...nextauth]/route';\r\nimport { getConversationsForUser } from '@/lib/data';\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const session = await getServerSession(authOptions);\r\n  \r\n  if (!session?.user) {\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n  }\r\n  \r\n  const userId = (session.user as any).id;\r\n  const conversations = await getConversationsForUser(userId);\r\n  \r\n  return NextResponse.json(conversations);\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;AAEA;;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,MAAM,UAAU,MAAM,IAAA,mKAAgB,EAAC;IAEvC,IAAI,CAAC,SAAS,MAAM;QAClB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;IAEA,MAAM,SAAS,AAAC,QAAQ,IAAI,CAAS,EAAE;IACvC,MAAM,gBAAgB,MAAM,IAAA,wIAAuB,EAAC;IAEpD,OAAO,gJAAY,CAAC,IAAI,CAAC;AAC3B"}}]
}